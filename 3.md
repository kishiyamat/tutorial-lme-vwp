---
layout: post
title: 一般化線形混合モデル
description: LMEの解説ページ <a href="./">  🏠  <a><br>
    <a href="./2.html">⏪</a> 最短で乗り切ります。 <a href="./0.html">⏩</a>
---

これまでのところで様々な値に対応するための
「一般化線形モデル(GLM)」を学んできました。
線形モデル(LM)を組むには `data.frame`と`formula`、`model` が必要で、
さらにGLMを組むには `family` の指定が必要だ、ということをこれまでで学びました。
以下のコードを見て思い出しましょう。

```r
f = Correct ~ logistic(Days)
m = glm(f, sleepstudy, family=binomial)
summary(m)
```

なぜ`binomial`かといえば、`Correct`が二項分布に従うからでしたね。
また結果の解釈には「リンク関数」が必要でした。
`binomial`の場合、`logit`関数が相当したことを思い出しましょう。
解釈に不安が残る場合は前回の内容を再度実行して
`exp(ax)+exp(b)`が何を示すのかを考えましょう。

前回までのところまででLMを一般化させる方向は達成したので、
今回は「混合」の部分を足しましょう。
とはいえ、前回の内容に比べればだいぶ簡単で、
Rにおける `|` の役割を確認するだけです[^bar]。
まずは実データに触れながら  <u>(ii) 構造を表現する表記</u> を確認します。
そして<u>(i) 構造的なノイズを扱うメリット</u> を抑え、
最後に <u>(iii) glmer を用いた一般化線形モデル</u> を実際に作成してみます。

[^bar]: バーとかパイプとか呼ばれていますが、Rのパイプは別のものを示す場合が多いので、
    バーとしましょう。

## 構造を表現する表記

とりあえず以下のコードを実行してプロットしてみる。
Unit1でみた図で
右のペインの **Plots** を押すと拡大されて `Subject` ごとに
`xyplot` が作れる。
どうしても拡大できない人は `#` を外して
サブセットを見てみる。

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lme4)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
  </code>
  <code data-type="sample-code">
    f = Reaction ~ Days | Subject # 前回の範囲
    xyplot(f, sleepstudy, type=c("p", "r"),
           # subset=Subject %in% c(370, 371)
           )
  </code>
  <code data-type="solution">
    f = Reaction ~ Days | Subject
    xyplot(f, sleepstudy, type=c("p", "r"),
           subset=Subject %in% c(370, 371))
  </code>
  <code data-type="sct">
    test_function("xyplot")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

まず `Subject` ごとに図が書かれたことが分かると思う。
まず表記として `Days | Subject` は `Subject` ごとにという意味
被験者ごとに傾きが全然違う。傾きだけではなく、切片も違う。
ではそれを分析することが
「被験者のばらつきを考慮する」
ことになるのだろうか。

## 構造的なノイズを扱うメリット

被験者ごとに傾きが全然違う。傾きだけではなく、切片も違う。
ではそれを分析することが「被験者のばらつきを考慮する」？
Rなら `lmList` という関数を使って
`Days | Subject` 、
つまり被験者ごとの`Days`の効果を求められる。
同じ formula を使って見る。

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lme4)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
  </code>
  <code data-type="sample-code">
    f = Reaction ~ Days | Subject # 前回の範囲
    lmList(f, sleepstudy)
  </code>
  <code data-type="solution">
    f = Reaction ~ Days | Subject
    lmList(f, sleepstudy)
  </code>
  <code data-type="sct">
    test_function("lmList")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

被験者ごとにDaysとReactionの関係を求められた。
確かに被験者のばらつきは見れている。
でも被験者分のモデルをしてなんだというのか。
「大体の人によっては効果ありました。」となる。
せっかく統計を使ってるのに「代替ってなんだよ」となる。
そうではなくて、被験者のばらつきを考慮しつつ要因の効果を見たい。

仮に 「共通の傾き」というのがあって、被験者ごとにノイズが乗っている。
と考えてみる。
そうすると、ここのばらつきを考慮したまま
報告する値は一つでいい。被験者全部を報告しなくていい。
このように被験者のばらつきも考慮して
全体の共通の、固定された効果を見るために混合効果モデルがある。

## glmer を用いた一般化線形混合モデル

Rで一般化線形混合モデルを作成するための関数には
`glmer`と`lmer`がある。
`glmer`のgは一般化(generalized)のgなので、
`lmer`は一般化されてない線形混合モデルを示すと分かる。
まずは「線形混合モデル」から考える。
線形モデルでは `f = Reaction ~ Days` だったのに対し、
線形混合モデルでは `f = Reaction ~ Days  + (Days | Subject)`
と括弧でノイズを表現する。 このとき`Days`を固定効果、
`(Days | Subject)`をランダム効果
と呼ぶ。

先程は `f = Reaction ~ Days | Subject`
としたが、`f = Reaction ~ Days  + (Days | Subject)`
と何が違うのだろうか。
今のままだと被験者のばらつきしか考慮していない。
`f = Reaction ~ Days` に加えて`(Days | Subject)` も
といっているので、
これを被験者のばらつきも考慮している。
少し話が抽象的なので手を動かす。

Reactionが正規分布に従っていると前提を起き[^normal]、
まずは`model` に`lmer`を使いましょう。
データは `sleepstudy`で
`formula` は`f = Reaction ~ Days  + (Days | Subject)`です。
後で試す `glmer`の時は見ないでこのformulaを
作れるようになりましょう。
`coef(m)$Subject`と `ranef(m)$Subject`
は一旦無視。

[^normal]: もちろん Gamma分布や対数正規分布過程してもいいが、
    その場合は glmer を使うことになるのと、
    Gamma分布の際は解釈が難しくなる。
    対数正規分布は試したが(glmerで`family=gaussian(link=log)`)、
    どうも切片のランダム効果が小さくなりすぎて
    警告を受けた。

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lmerTest)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
  </code>
  <code data-type="sample-code">
    f = Reaction ~ Days + (Days | Subject)
    m = lmer(f, sleepstudy)
    summary(m)
    # coef(m)$Subject
    # ranef(m)$Subject
  </code>
  <code data-type="solution">
    f = Reaction ~ Days + (Days | Subject)
    m = lmer(f, sleepstudy)
    summary(m)
  </code>
  <code data-type="sct">
    test_function("summary")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

はい。モデリングできました。
さっきの list ではバラバラだったが、まとまっている。
`Days` が lmer の結果、
`(Days | Subject)` が `ranef(m)$Subject`の結果。
たすと `coef(m)$Subject` になる。
気持ち的には
$Reaction = a \cdot Days + b + (a_{subject} \cdot Days_{subject} + b_{subject})$ としている
感覚だ。
`Reaction ~ Days + (Days | Subject)` で
Days だけでなく被験者ごとのDaysの傾きを求める。
 



これを一般化してようやく「一般化線形混合モデル」になる。
お疲れ様でした。
`Correct` と `Days` の関係をランダム効果ありで作成し、
`glmer` 関数を使って `family` は `Correct` が従う分布を選択してください。

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lme4)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
  </code>
  <code data-type="sample-code">
    f = Correct ~ Days + (Days | Subject)
    m = glmer(f, sleepstudy, family=binomial)
    summary(m)
    # coef(m)$Subject
    # ranef(m)$Subject
  </code>
  <code data-type="solution">
    f = Correct ~ Days + (Days | Subject)
    glmer(f, sleepstudy, family=binomial)
    summary(m)
  </code>
  <code data-type="sct">
    test_function("summary")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

これが意味するところは

1. Correct は 固定効果 Days だけでなく
   構造的なランダムな効果も持っています。
   `Correct ~ Days + (Days | Subject)`
1. これらの列を含むデータは `sleepstudy` です。
1. ただし、Correct は二項分布に従います `family=binomial`
1. なお、一般化した混合効果モデルとして `glmer` を使います。

です。

## まとめ

これで統計のチュートリアルは終わりです。
線形モデルで要因の効果を検証し、
一般化して様々な分布に対応が可能であることを学び、
構造的なノイズを組み込める。

分析はできるようになった。
でも実験の組み方や要因の選び方のコツは反論できるようにすること。
いわゆる交互作用について。

「単語の長さ」が認知的不可に影響してるのでは？
ツッコミとして「単語の頻度なんじゃないの？」
`認知的不可 ~ 単語の長さ*単語の頻度` とモデルを組む。
そうすると「たしかにそうかもだけど、統計的には効果ありませんよ」と交わせる。
`認知的不可 ~ 単語の長さ` だけだと何も言えない。実験のやり直しになる。
構造的なノイズの気持ちもおなじ。
ツッコミとして「被験者によるんじゃないの？」
だからモデルに組み込んで「そうかもだけど、考慮しても効果はありましたよ」とかわせる。

相手の反論に対応するためには
「その話が本当ならXだよね。で、Yになってる？
Yになってないんでそれ違います」と持っていく。
あるいは持っていけないかもしれない。それはそれで進歩。
一番さけないと行けないのは、
その判断材料を相手に提示できないこと。
周りの人に 「交絡してないかな」 とチェックしてもらいましょう。
交絡してたら要因にいれましょう、それだけです。

[Extracting slopes for cases from a mixed effects model (lme4)][lme-ranef]

[lme-ranef]: https://stats.stackexchange.com/questions/122009/extracting-slopes-for-cases-from-a-mixed-effects-model-lme4
https://stats.stackexchange.com/questions/22988/how-to-obtain-the-p-value-check-significance-of-an-effect-in-a-lme4-mixed-mode

[back](./)
