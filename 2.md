---
layout: post
title: 一般化線形モデル
description: LMEの解説ページ
    <a href="./">  🏠  <a>
---

[前回][u1] はチュートリアルのモチベーションとゴール、
そして線形モデルをつくりました。
またRでモデルを作るには3つの要素が必要だとも述べました。
今回は前回で述べたゴール、
「直線以外の関係 に一般化させる」
について取り組んでいきます。
もう一度モチベーションを振り返りましょう。

まず前回の $y = ax_1 + b$ は `lm` でモデルを作成できますが、
これは $y$ が要因に対して直線の関係にあることや負の値を取れることを仮定してました。
なので $y$ が整数の場合や範囲の指定がある場合に不適切なモデルとなります。
そこで直線以外も扱えるよう一般化したのが「<u>一般化</u>線形モデル」である、
という話でした。

この一般化線形モデルを理解するため、
まずは実例のデータに触れながら <u>(i) 線形モデルを使うことの問題 </u> を確認します。
そして <u>(ii) 問題を解決するための「リンク関数」という概念 </u> を抑え、
最後に <u>(iii) glm を用いた一般化線形モデル </u> を実際に作成してみます。
<!--
GLMの説明にはよく「ログオッズ」という表現が出てくるのですが、
そもそも「オッズ」がピンとこないのでそこら辺もケアします。
-->  

## 直線の当てはめで起きそうな問題

まずは直線の問題点を見るために `xyplot()` を使いましょう。
前回の `sleepstudy` に `Correct` という「回答の正解/不正解(1/0)」を追加しました。
今回は `Days` が `Correct` を説明するかを検証するので、
以下の `f` に `formula` を作成してください。
可視化のしやすさのため `data.frame` は 350番の被験者データ(`sleepstudy_350`) を使います。

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lme4)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
    sleepstudy_350 = subset(sleepstudy, Subject==350)
  </code>
  <code data-type="sample-code">
    # f = Reaction ~ Days # 前回の範囲
    f = 
    # プロット(p)と回帰(r)の直線も描画
    xyplot(f, sleepstudy_350, type=c("p", "r"))
    # 余裕があれば `lm` を用いた回帰分析も確認
    # lm(f, sleepstudy_350)
  </code>
  <code data-type="solution">
    f = Correct ~ Days
    xyplot(f, sleepstudy_350, type=c("p", "r"))
  </code>
  <code data-type="sct">
    test_function("xyplot")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

当てはめられた傾きが右肩下がりなので、
日にちが増すほど正解が減ることは分かります。
しかしDays によっては0--1の範囲を超えてしまいそうだ、
ということも分かると思います。
`lm` を用いた回帰分析をした結果からも
切片は1を超えており Daysが0
の時におかしなことになります。
この問題を抽象化すると、
「$Y = ax + b$ の $Y$ に範囲の制限があるとき、
直線の当てはめが不適切になる」
ということになります。

## リンク関数

以上は「範囲指定があるときに直線の当てはめをすると範囲外に飛びだしてしまう」
という問題でした。
ただ、 $ax+b$ が直線である以上、傾きが0でない限りいつかは飛び出します。
そこで $ax+b$ を必ず 0--1 の間に収めてくれるような
関数 $\textrm{logistic}$ を考えてみましょう。

    logistic = function(x) {1 / (1 + exp(-x))}

この値を 0--1 の間に収めることが意味するところは
「実数を確率の値に変換してくれる」ということです。
つまり $Days$ が増えるほど $a \cdot Days + b$ の値は減り (まだ0--1ではない)、
そこで $\textrm{logistic} (a \cdot Days + b)$ とすると、
正答する確率が下がる (0--1に収まる) と変換してくれます。

一旦これをモデリングしてみましょう。
`logistic` という関数はこちらで用意しておいたので
$Correct = \textrm{logistic}(a \cdot Days + b)$
を `formula` で表現して `lm` モデルに入れましょう。
ただ、$a, b$ は推定対象なので
`formula` には入れないことに注意しましょう。

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lme4)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
  </code>
  <code data-type="sample-code">
    # f = Correct ~ Days  # Days を非線形に変換
    f = 
    m = lm(f, sleepstudy)
    summary(m)
  </code>
  <code data-type="solution">
    f = Correct ~ logistic(Days)
    m = lm(f, sleepstudy)
    summary(m)
  </code>
  <code data-type="sct">
    test_function("summary")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

切片はxが0の時、どれくらい1になりやすいかのバイアス。
つまり寝不足0なら普通は正答率が1ということ。
そしてDaysが1増えると何倍ミスしやすくなるかが傾きで
1増えると-0.45ということは1増えると

現状は0--1の値を求めて 0や1との差分を少なくしている。
理想は0か1を求めてあるべきパラメータを最適化したい。
誤差の求めかた: 0か1か。


よく出てくる「ロジット関数」。
これはlog(p/(1-p))になる。
つまりlog(p)-log(1-p)になる。
log(p)とは
"1-p"は「起きない確率」
つまり、起きない

<div data-datacamp-exercise data-lang="r">
  <code data-type="pre-exercise-code">
    library(lattice); library(lme4)
    set.seed(43)
    # data
    rt = sleepstudy$Reaction
    logistic = function(x) {1 / (1 + exp(-x))}
    scale = function(x) (x-min(x))/(max(x)-min(x))
    ps = logistic(-5*scale(rt)+2)
    xs = as.integer(rbinom(ps, n=length(ps), size=1))
    sleepstudy$Correct = xs
    logit = function(p) log(p/(1-p))
  </code>
  <code data-type="sample-code">
    # f = Correct ~ Days  # Days を非線形に変換
    f = 
    m = lm(f, sleepstudy)
    summary(m)
  </code>
  <code data-type="solution">
    f = logit(Correct) ~ Days
    m = lm(f, sleepstudy)
    summary(m)
  </code>
  <code data-type="sct">
    test_function("summary")
    success_msg("Great job!")
  </code>
  <div data-type="hint">
    前回は Reaction ~ Days を見ましたね。今回は Correct を見ましょう。
  </div>
</div>

実際に線を引いてみよう。
全体的に正答しやすい
逆関数。

$\textrm{logit}(Correct) = a Days + b$
でも同じ。今度は Correct を0--1の外を許してあげている。

そこから <u>2. 確率の値に基づいて正誤(0/1)が生成される</u>
という結果となります。






ただ、
これはつまり、



$Y(非直線) ~ F(ax+b)$

つまり、一旦別の関数を噛ませて

直線でない

y=ax+b ではなく y=f(ax+b) を考える。
yには0や1,
ax+bには200など。
これを0--1の値に収める関数;
一旦収めると y=1の時に 0.2だったら変.
y=0の時に 0.8 だったら変。
そういう感じで aやbの値を更新できる。


カーブして欲しい。
これは0--1の連続


ここまでをまとめると







[u1]: ./1.html
[u2]: ./2.html
[u3]: ./3.html
